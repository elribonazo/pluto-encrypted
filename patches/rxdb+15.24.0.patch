diff --git a/node_modules/rxdb/dist/cjs/plugins/encryption-crypto-js/index.js b/node_modules/rxdb/dist/cjs/plugins/encryption-crypto-js/index.js
deleted file mode 100644
index 6b6831e..0000000
--- a/node_modules/rxdb/dist/cjs/plugins/encryption-crypto-js/index.js
+++ /dev/null
@@ -1,147 +0,0 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.MINIMUM_PASSWORD_LENGTH = void 0;
-exports.decryptString = decryptString;
-exports.encryptString = encryptString;
-exports.wrappedKeyEncryptionCryptoJsStorage = wrappedKeyEncryptionCryptoJsStorage;
-var _cryptoJs = _interopRequireDefault(require("crypto-js"));
-var _pluginHelpers = require("../../plugin-helpers.js");
-var _rxError = require("../../rx-error.js");
-var _rxStorageHelper = require("../../rx-storage-helper.js");
-var _index = require("../../plugins/utils/index.js");
-/**
- * this plugin adds the encryption-capabilities to rxdb
- * It's using crypto-js/aes for password-encryption
- * @link https://github.com/brix/crypto-js
- */
-
-var {
-  AES,
-  enc: cryptoEnc
-} = _cryptoJs.default;
-var MINIMUM_PASSWORD_LENGTH = exports.MINIMUM_PASSWORD_LENGTH = 8;
-function encryptString(value, password) {
-  var encrypted = AES.encrypt(value, password);
-  return encrypted.toString();
-}
-function decryptString(cipherText, password) {
-  /**
-   * Trying to decrypt non-strings
-   * will cause no errors and will be hard to debug.
-   * So instead we do this check here.
-   */
-  if (typeof cipherText !== 'string') {
-    throw (0, _rxError.newRxError)('SNH', {
-      args: {
-        cipherText
-      }
-    });
-  }
-  var decrypted = AES.decrypt(cipherText, password);
-  var ret = decrypted.toString(cryptoEnc.Utf8);
-  return ret;
-}
-function wrappedKeyEncryptionCryptoJsStorage(args) {
-  return Object.assign({}, args.storage, {
-    async createStorageInstance(params) {
-      if (typeof params.password !== 'undefined') {
-        validatePassword(params.password);
-      }
-      if (!(0, _rxStorageHelper.hasEncryption)(params.schema)) {
-        var retInstance = await args.storage.createStorageInstance(params);
-        return retInstance;
-      }
-      if (!params.password) {
-        throw (0, _rxError.newRxError)('EN3', {
-          database: params.databaseName,
-          collection: params.collectionName,
-          schema: params.schema
-        });
-      }
-      var password = params.password;
-      var schemaWithoutEncrypted = (0, _index.clone)(params.schema);
-      delete schemaWithoutEncrypted.encrypted;
-      if (schemaWithoutEncrypted.attachments) {
-        schemaWithoutEncrypted.attachments.encrypted = false;
-      }
-      var instance = await args.storage.createStorageInstance(Object.assign({}, params, {
-        schema: schemaWithoutEncrypted
-      }));
-      function modifyToStorage(docData) {
-        docData = cloneWithoutAttachments(docData);
-        (0, _index.ensureNotFalsy)(params.schema.encrypted).forEach(path => {
-          var value = (0, _index.getProperty)(docData, path);
-          if (typeof value === 'undefined') {
-            return;
-          }
-          var stringValue = JSON.stringify(value);
-          var encrypted = encryptString(stringValue, password);
-          (0, _index.setProperty)(docData, path, encrypted);
-        });
-
-        // handle attachments
-        if (params.schema.attachments && params.schema.attachments.encrypted) {
-          var newAttachments = {};
-          Object.entries(docData._attachments).forEach(([id, attachment]) => {
-            var useAttachment = (0, _index.flatClone)(attachment);
-            if (useAttachment.data) {
-              var dataString = useAttachment.data;
-              useAttachment.data = (0, _index.b64EncodeUnicode)(encryptString(dataString, password));
-            }
-            newAttachments[id] = useAttachment;
-          });
-          docData._attachments = newAttachments;
-        }
-        return docData;
-      }
-      function modifyFromStorage(docData) {
-        docData = cloneWithoutAttachments(docData);
-        (0, _index.ensureNotFalsy)(params.schema.encrypted).forEach(path => {
-          var value = (0, _index.getProperty)(docData, path);
-          if (typeof value === 'undefined') {
-            return;
-          }
-          var decrypted = decryptString(value, password);
-          var decryptedParsed = JSON.parse(decrypted);
-          (0, _index.setProperty)(docData, path, decryptedParsed);
-        });
-        return docData;
-      }
-      function modifyAttachmentFromStorage(attachmentData) {
-        if (params.schema.attachments && params.schema.attachments.encrypted) {
-          var decrypted = decryptString((0, _index.b64DecodeUnicode)(attachmentData), password);
-          return decrypted;
-        } else {
-          return attachmentData;
-        }
-      }
-      return (0, _pluginHelpers.wrapRxStorageInstance)(params.schema, instance, modifyToStorage, modifyFromStorage, modifyAttachmentFromStorage);
-    }
-  });
-}
-function cloneWithoutAttachments(data) {
-  var attachments = data._attachments;
-  data = (0, _index.flatClone)(data);
-  delete data._attachments;
-  data = (0, _index.clone)(data);
-  data._attachments = attachments;
-  return data;
-}
-function validatePassword(password) {
-  if (typeof password !== 'string') {
-    throw (0, _rxError.newRxTypeError)('EN1', {
-      password
-    });
-  }
-  if (password.length < MINIMUM_PASSWORD_LENGTH) {
-    throw (0, _rxError.newRxError)('EN2', {
-      minPassLength: MINIMUM_PASSWORD_LENGTH,
-      password
-    });
-  }
-}
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/cjs/plugins/encryption-crypto-js/index.js.map b/node_modules/rxdb/dist/cjs/plugins/encryption-crypto-js/index.js.map
deleted file mode 100644
index 1267b8e..0000000
--- a/node_modules/rxdb/dist/cjs/plugins/encryption-crypto-js/index.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"index.js","names":["_cryptoJs","_interopRequireDefault","require","_pluginHelpers","_rxError","_rxStorageHelper","_index","AES","enc","cryptoEnc","pkg","MINIMUM_PASSWORD_LENGTH","exports","encryptString","value","password","encrypted","encrypt","toString","decryptString","cipherText","newRxError","args","decrypted","decrypt","ret","Utf8","wrappedKeyEncryptionCryptoJsStorage","Object","assign","storage","createStorageInstance","params","validatePassword","hasEncryption","schema","retInstance","database","databaseName","collection","collectionName","schemaWithoutEncrypted","clone","attachments","instance","modifyToStorage","docData","cloneWithoutAttachments","ensureNotFalsy","forEach","path","getProperty","stringValue","JSON","stringify","setProperty","newAttachments","entries","_attachments","id","attachment","useAttachment","flatClone","data","dataString","b64EncodeUnicode","modifyFromStorage","decryptedParsed","parse","modifyAttachmentFromStorage","attachmentData","b64DecodeUnicode","wrapRxStorageInstance","newRxTypeError","length","minPassLength"],"sources":["../../../../src/plugins/encryption-crypto-js/index.ts"],"sourcesContent":["/**\n * this plugin adds the encryption-capabilities to rxdb\n * It's using crypto-js/aes for password-encryption\n * @link https://github.com/brix/crypto-js\n */\nimport pkg from 'crypto-js';\nconst { AES, enc: cryptoEnc } = pkg;\n\nimport { wrapRxStorageInstance } from '../../plugin-helpers.ts';\nimport { newRxError, newRxTypeError } from '../../rx-error.ts';\nimport { hasEncryption } from '../../rx-storage-helper.ts';\nimport type {\n    InternalStoreDocType,\n    RxAttachmentWriteData,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxJsonSchema,\n    RxStorage,\n    RxStorageInstanceCreationParams\n} from '../../types/index.d.ts';\nimport {\n    b64DecodeUnicode,\n    b64EncodeUnicode,\n    clone,\n    ensureNotFalsy,\n    flatClone,\n    getProperty,\n    setProperty\n} from '../../plugins/utils/index.ts';\n\nexport const MINIMUM_PASSWORD_LENGTH: 8 = 8;\n\n\nexport function encryptString(value: string, password: string): string {\n    const encrypted = AES.encrypt(value, password);\n    return encrypted.toString();\n}\n\nexport function decryptString(cipherText: string, password: any): string {\n    /**\n     * Trying to decrypt non-strings\n     * will cause no errors and will be hard to debug.\n     * So instead we do this check here.\n     */\n    if (typeof cipherText !== 'string') {\n        throw newRxError('SNH', {\n            args: {\n                cipherText\n            }\n        });\n    }\n\n    const decrypted = AES.decrypt(cipherText, password);\n    const ret = decrypted.toString(cryptoEnc.Utf8);\n    return ret;\n}\n\nexport type InternalStorePasswordDocType = InternalStoreDocType<{\n    hash: string;\n}>;\n\nexport function wrappedKeyEncryptionCryptoJsStorage<Internals, InstanceCreationOptions>(\n    args: {\n        storage: RxStorage<Internals, InstanceCreationOptions>;\n    }\n): RxStorage<Internals, InstanceCreationOptions> {\n    return Object.assign(\n        {},\n        args.storage,\n        {\n            async createStorageInstance<RxDocType>(\n                params: RxStorageInstanceCreationParams<RxDocType, any>\n            ) {\n                if (typeof params.password !== 'undefined') {\n                    validatePassword(params.password as any);\n                }\n\n                if (!hasEncryption(params.schema)) {\n                    const retInstance = await args.storage.createStorageInstance(params);\n                    return retInstance;\n                }\n\n                if (!params.password) {\n                    throw newRxError('EN3', {\n                        database: params.databaseName,\n                        collection: params.collectionName,\n                        schema: params.schema\n                    });\n                }\n                const password = params.password;\n\n                const schemaWithoutEncrypted: RxJsonSchema<RxDocumentData<RxDocType>> = clone(params.schema);\n                delete schemaWithoutEncrypted.encrypted;\n                if (schemaWithoutEncrypted.attachments) {\n                    schemaWithoutEncrypted.attachments.encrypted = false;\n                }\n\n                const instance = await args.storage.createStorageInstance(\n                    Object.assign(\n                        {},\n                        params,\n                        {\n                            schema: schemaWithoutEncrypted\n                        }\n                    )\n                );\n\n                function modifyToStorage(docData: RxDocumentWriteData<RxDocType>) {\n                    docData = cloneWithoutAttachments(docData);\n                    ensureNotFalsy(params.schema.encrypted)\n                        .forEach(path => {\n                            const value = getProperty(docData, path);\n                            if (typeof value === 'undefined') {\n                                return;\n                            }\n\n                            const stringValue = JSON.stringify(value);\n                            const encrypted = encryptString(stringValue, password);\n                            setProperty(docData, path, encrypted);\n                        });\n\n                    // handle attachments\n                    if (\n                        params.schema.attachments &&\n                        params.schema.attachments.encrypted\n                    ) {\n                        const newAttachments: typeof docData._attachments = {};\n                        Object.entries(docData._attachments).forEach(([id, attachment]) => {\n                            const useAttachment: RxAttachmentWriteData = flatClone(attachment) as any;\n                            if (useAttachment.data) {\n                                const dataString = useAttachment.data;\n                                useAttachment.data = b64EncodeUnicode(encryptString(dataString, password));\n                            }\n                            newAttachments[id] = useAttachment;\n                        });\n                        docData._attachments = newAttachments;\n                    }\n                    return docData;\n                }\n                function modifyFromStorage(docData: RxDocumentData<any>): Promise<RxDocumentData<RxDocType>> {\n                    docData = cloneWithoutAttachments(docData);\n                    ensureNotFalsy(params.schema.encrypted)\n                        .forEach(path => {\n                            const value = getProperty(docData, path);\n                            if (typeof value === 'undefined') {\n                                return;\n                            }\n                            const decrypted = decryptString(value, password);\n                            const decryptedParsed = JSON.parse(decrypted);\n                            setProperty(docData, path, decryptedParsed);\n                        });\n                    return docData;\n                }\n\n                function modifyAttachmentFromStorage(attachmentData: string): string {\n                    if (\n                        params.schema.attachments &&\n                        params.schema.attachments.encrypted\n                    ) {\n                        const decrypted = decryptString(b64DecodeUnicode(attachmentData), password);\n                        return decrypted;\n                    } else {\n                        return attachmentData;\n                    }\n                }\n\n                return wrapRxStorageInstance(\n                    params.schema,\n                    instance,\n                    modifyToStorage,\n                    modifyFromStorage,\n                    modifyAttachmentFromStorage\n                );\n            }\n        }\n    );\n}\n\n\n\n\n\nfunction cloneWithoutAttachments<T>(data: RxDocumentWriteData<T>): RxDocumentData<T> {\n    const attachments = data._attachments;\n    data = flatClone(data);\n    delete (data as any)._attachments;\n    data = clone(data);\n    data._attachments = attachments;\n    return data as any;\n}\n\nfunction validatePassword(password: string) {\n    if (typeof password !== 'string') {\n        throw newRxTypeError('EN1', {\n            password\n        });\n    }\n    if (password.length < MINIMUM_PASSWORD_LENGTH) {\n        throw newRxError('EN2', {\n            minPassLength: MINIMUM_PASSWORD_LENGTH,\n            password\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/cjs/plugins/test-utils/config.js b/node_modules/rxdb/dist/cjs/plugins/test-utils/config.js
index 9ff71b6..ae745ea 100644
--- a/node_modules/rxdb/dist/cjs/plugins/test-utils/config.js
+++ b/node_modules/rxdb/dist/cjs/plugins/test-utils/config.js
@@ -6,7 +6,6 @@ Object.defineProperty(exports, "__esModule", {
 });
 exports.ENV_VARIABLES = exports.DEFAULT_STORAGE = void 0;
 exports.getConfig = getConfig;
-exports.getEncryptedStorage = getEncryptedStorage;
 exports.getPassword = getPassword;
 exports.initTestEnvironment = initTestEnvironment;
 exports.isDeno = exports.isBun = void 0;
@@ -17,7 +16,6 @@ exports.setConfig = setConfig;
 var _index = require("../utils/index.js");
 var _broadcastChannel = require("broadcast-channel");
 var _nodeEvents = _interopRequireDefault(require("node:events"));
-var _index2 = require("../encryption-crypto-js/index.js");
 /// <reference path="../../../node_modules/@types/mocha/index.d.ts" />
 
 var isDeno = exports.isDeno = typeof window !== 'undefined' && 'Deno' in window;
@@ -99,12 +97,6 @@ function initTestEnvironment() {
     };
   }
 }
-function getEncryptedStorage(baseStorage = getConfig().storage.getStorage()) {
-  var ret = config.storage.hasEncryption ? baseStorage : (0, _index2.wrappedKeyEncryptionCryptoJsStorage)({
-    storage: baseStorage
-  });
-  return ret;
-}
 function isNotOneOfTheseStorages(storageNames) {
   var isName = getConfig().storage.name;
   if (storageNames.includes(isName)) {
diff --git a/node_modules/rxdb/dist/esm/plugins/encryption-crypto-js/index.js b/node_modules/rxdb/dist/esm/plugins/encryption-crypto-js/index.js
deleted file mode 100644
index a15ff31..0000000
--- a/node_modules/rxdb/dist/esm/plugins/encryption-crypto-js/index.js
+++ /dev/null
@@ -1,136 +0,0 @@
-/**
- * this plugin adds the encryption-capabilities to rxdb
- * It's using crypto-js/aes for password-encryption
- * @link https://github.com/brix/crypto-js
- */
-import pkg from 'crypto-js';
-var {
-  AES,
-  enc: cryptoEnc
-} = pkg;
-import { wrapRxStorageInstance } from "../../plugin-helpers.js";
-import { newRxError, newRxTypeError } from "../../rx-error.js";
-import { hasEncryption } from "../../rx-storage-helper.js";
-import { b64DecodeUnicode, b64EncodeUnicode, clone, ensureNotFalsy, flatClone, getProperty, setProperty } from "../../plugins/utils/index.js";
-export var MINIMUM_PASSWORD_LENGTH = 8;
-export function encryptString(value, password) {
-  var encrypted = AES.encrypt(value, password);
-  return encrypted.toString();
-}
-export function decryptString(cipherText, password) {
-  /**
-   * Trying to decrypt non-strings
-   * will cause no errors and will be hard to debug.
-   * So instead we do this check here.
-   */
-  if (typeof cipherText !== 'string') {
-    throw newRxError('SNH', {
-      args: {
-        cipherText
-      }
-    });
-  }
-  var decrypted = AES.decrypt(cipherText, password);
-  var ret = decrypted.toString(cryptoEnc.Utf8);
-  return ret;
-}
-export function wrappedKeyEncryptionCryptoJsStorage(args) {
-  return Object.assign({}, args.storage, {
-    async createStorageInstance(params) {
-      if (typeof params.password !== 'undefined') {
-        validatePassword(params.password);
-      }
-      if (!hasEncryption(params.schema)) {
-        var retInstance = await args.storage.createStorageInstance(params);
-        return retInstance;
-      }
-      if (!params.password) {
-        throw newRxError('EN3', {
-          database: params.databaseName,
-          collection: params.collectionName,
-          schema: params.schema
-        });
-      }
-      var password = params.password;
-      var schemaWithoutEncrypted = clone(params.schema);
-      delete schemaWithoutEncrypted.encrypted;
-      if (schemaWithoutEncrypted.attachments) {
-        schemaWithoutEncrypted.attachments.encrypted = false;
-      }
-      var instance = await args.storage.createStorageInstance(Object.assign({}, params, {
-        schema: schemaWithoutEncrypted
-      }));
-      function modifyToStorage(docData) {
-        docData = cloneWithoutAttachments(docData);
-        ensureNotFalsy(params.schema.encrypted).forEach(path => {
-          var value = getProperty(docData, path);
-          if (typeof value === 'undefined') {
-            return;
-          }
-          var stringValue = JSON.stringify(value);
-          var encrypted = encryptString(stringValue, password);
-          setProperty(docData, path, encrypted);
-        });
-
-        // handle attachments
-        if (params.schema.attachments && params.schema.attachments.encrypted) {
-          var newAttachments = {};
-          Object.entries(docData._attachments).forEach(([id, attachment]) => {
-            var useAttachment = flatClone(attachment);
-            if (useAttachment.data) {
-              var dataString = useAttachment.data;
-              useAttachment.data = b64EncodeUnicode(encryptString(dataString, password));
-            }
-            newAttachments[id] = useAttachment;
-          });
-          docData._attachments = newAttachments;
-        }
-        return docData;
-      }
-      function modifyFromStorage(docData) {
-        docData = cloneWithoutAttachments(docData);
-        ensureNotFalsy(params.schema.encrypted).forEach(path => {
-          var value = getProperty(docData, path);
-          if (typeof value === 'undefined') {
-            return;
-          }
-          var decrypted = decryptString(value, password);
-          var decryptedParsed = JSON.parse(decrypted);
-          setProperty(docData, path, decryptedParsed);
-        });
-        return docData;
-      }
-      function modifyAttachmentFromStorage(attachmentData) {
-        if (params.schema.attachments && params.schema.attachments.encrypted) {
-          var decrypted = decryptString(b64DecodeUnicode(attachmentData), password);
-          return decrypted;
-        } else {
-          return attachmentData;
-        }
-      }
-      return wrapRxStorageInstance(params.schema, instance, modifyToStorage, modifyFromStorage, modifyAttachmentFromStorage);
-    }
-  });
-}
-function cloneWithoutAttachments(data) {
-  var attachments = data._attachments;
-  data = flatClone(data);
-  delete data._attachments;
-  data = clone(data);
-  data._attachments = attachments;
-  return data;
-}
-function validatePassword(password) {
-  if (typeof password !== 'string') {
-    throw newRxTypeError('EN1', {
-      password
-    });
-  }
-  if (password.length < MINIMUM_PASSWORD_LENGTH) {
-    throw newRxError('EN2', {
-      minPassLength: MINIMUM_PASSWORD_LENGTH,
-      password
-    });
-  }
-}
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/esm/plugins/encryption-crypto-js/index.js.map b/node_modules/rxdb/dist/esm/plugins/encryption-crypto-js/index.js.map
deleted file mode 100644
index da1db89..0000000
--- a/node_modules/rxdb/dist/esm/plugins/encryption-crypto-js/index.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"index.js","names":["pkg","AES","enc","cryptoEnc","wrapRxStorageInstance","newRxError","newRxTypeError","hasEncryption","b64DecodeUnicode","b64EncodeUnicode","clone","ensureNotFalsy","flatClone","getProperty","setProperty","MINIMUM_PASSWORD_LENGTH","encryptString","value","password","encrypted","encrypt","toString","decryptString","cipherText","args","decrypted","decrypt","ret","Utf8","wrappedKeyEncryptionCryptoJsStorage","Object","assign","storage","createStorageInstance","params","validatePassword","schema","retInstance","database","databaseName","collection","collectionName","schemaWithoutEncrypted","attachments","instance","modifyToStorage","docData","cloneWithoutAttachments","forEach","path","stringValue","JSON","stringify","newAttachments","entries","_attachments","id","attachment","useAttachment","data","dataString","modifyFromStorage","decryptedParsed","parse","modifyAttachmentFromStorage","attachmentData","length","minPassLength"],"sources":["../../../../src/plugins/encryption-crypto-js/index.ts"],"sourcesContent":["/**\n * this plugin adds the encryption-capabilities to rxdb\n * It's using crypto-js/aes for password-encryption\n * @link https://github.com/brix/crypto-js\n */\nimport pkg from 'crypto-js';\nconst { AES, enc: cryptoEnc } = pkg;\n\nimport { wrapRxStorageInstance } from '../../plugin-helpers.ts';\nimport { newRxError, newRxTypeError } from '../../rx-error.ts';\nimport { hasEncryption } from '../../rx-storage-helper.ts';\nimport type {\n    InternalStoreDocType,\n    RxAttachmentWriteData,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxJsonSchema,\n    RxStorage,\n    RxStorageInstanceCreationParams\n} from '../../types/index.d.ts';\nimport {\n    b64DecodeUnicode,\n    b64EncodeUnicode,\n    clone,\n    ensureNotFalsy,\n    flatClone,\n    getProperty,\n    setProperty\n} from '../../plugins/utils/index.ts';\n\nexport const MINIMUM_PASSWORD_LENGTH: 8 = 8;\n\n\nexport function encryptString(value: string, password: string): string {\n    const encrypted = AES.encrypt(value, password);\n    return encrypted.toString();\n}\n\nexport function decryptString(cipherText: string, password: any): string {\n    /**\n     * Trying to decrypt non-strings\n     * will cause no errors and will be hard to debug.\n     * So instead we do this check here.\n     */\n    if (typeof cipherText !== 'string') {\n        throw newRxError('SNH', {\n            args: {\n                cipherText\n            }\n        });\n    }\n\n    const decrypted = AES.decrypt(cipherText, password);\n    const ret = decrypted.toString(cryptoEnc.Utf8);\n    return ret;\n}\n\nexport type InternalStorePasswordDocType = InternalStoreDocType<{\n    hash: string;\n}>;\n\nexport function wrappedKeyEncryptionCryptoJsStorage<Internals, InstanceCreationOptions>(\n    args: {\n        storage: RxStorage<Internals, InstanceCreationOptions>;\n    }\n): RxStorage<Internals, InstanceCreationOptions> {\n    return Object.assign(\n        {},\n        args.storage,\n        {\n            async createStorageInstance<RxDocType>(\n                params: RxStorageInstanceCreationParams<RxDocType, any>\n            ) {\n                if (typeof params.password !== 'undefined') {\n                    validatePassword(params.password as any);\n                }\n\n                if (!hasEncryption(params.schema)) {\n                    const retInstance = await args.storage.createStorageInstance(params);\n                    return retInstance;\n                }\n\n                if (!params.password) {\n                    throw newRxError('EN3', {\n                        database: params.databaseName,\n                        collection: params.collectionName,\n                        schema: params.schema\n                    });\n                }\n                const password = params.password;\n\n                const schemaWithoutEncrypted: RxJsonSchema<RxDocumentData<RxDocType>> = clone(params.schema);\n                delete schemaWithoutEncrypted.encrypted;\n                if (schemaWithoutEncrypted.attachments) {\n                    schemaWithoutEncrypted.attachments.encrypted = false;\n                }\n\n                const instance = await args.storage.createStorageInstance(\n                    Object.assign(\n                        {},\n                        params,\n                        {\n                            schema: schemaWithoutEncrypted\n                        }\n                    )\n                );\n\n                function modifyToStorage(docData: RxDocumentWriteData<RxDocType>) {\n                    docData = cloneWithoutAttachments(docData);\n                    ensureNotFalsy(params.schema.encrypted)\n                        .forEach(path => {\n                            const value = getProperty(docData, path);\n                            if (typeof value === 'undefined') {\n                                return;\n                            }\n\n                            const stringValue = JSON.stringify(value);\n                            const encrypted = encryptString(stringValue, password);\n                            setProperty(docData, path, encrypted);\n                        });\n\n                    // handle attachments\n                    if (\n                        params.schema.attachments &&\n                        params.schema.attachments.encrypted\n                    ) {\n                        const newAttachments: typeof docData._attachments = {};\n                        Object.entries(docData._attachments).forEach(([id, attachment]) => {\n                            const useAttachment: RxAttachmentWriteData = flatClone(attachment) as any;\n                            if (useAttachment.data) {\n                                const dataString = useAttachment.data;\n                                useAttachment.data = b64EncodeUnicode(encryptString(dataString, password));\n                            }\n                            newAttachments[id] = useAttachment;\n                        });\n                        docData._attachments = newAttachments;\n                    }\n                    return docData;\n                }\n                function modifyFromStorage(docData: RxDocumentData<any>): Promise<RxDocumentData<RxDocType>> {\n                    docData = cloneWithoutAttachments(docData);\n                    ensureNotFalsy(params.schema.encrypted)\n                        .forEach(path => {\n                            const value = getProperty(docData, path);\n                            if (typeof value === 'undefined') {\n                                return;\n                            }\n                            const decrypted = decryptString(value, password);\n                            const decryptedParsed = JSON.parse(decrypted);\n                            setProperty(docData, path, decryptedParsed);\n                        });\n                    return docData;\n                }\n\n                function modifyAttachmentFromStorage(attachmentData: string): string {\n                    if (\n                        params.schema.attachments &&\n                        params.schema.attachments.encrypted\n                    ) {\n                        const decrypted = decryptString(b64DecodeUnicode(attachmentData), password);\n                        return decrypted;\n                    } else {\n                        return attachmentData;\n                    }\n                }\n\n                return wrapRxStorageInstance(\n                    params.schema,\n                    instance,\n                    modifyToStorage,\n                    modifyFromStorage,\n                    modifyAttachmentFromStorage\n                );\n            }\n        }\n    );\n}\n\n\n\n\n\nfunction cloneWithoutAttachments<T>(data: RxDocumentWriteData<T>): RxDocumentData<T> {\n    const attachments = data._attachments;\n    data = flatClone(data);\n    delete (data as any)._attachments;\n    data = clone(data);\n    data._attachments = attachments;\n    return data as any;\n}\n\nfunction validatePassword(password: string) {\n    if (typeof password !== 'string') {\n        throw newRxTypeError('EN1', {\n            password\n        });\n    }\n    if (password.length < MINIMUM_PASSWORD_LENGTH) {\n        throw newRxError('EN2', {\n            minPassLength: MINIMUM_PASSWORD_LENGTH,\n            password\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]}
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/esm/plugins/test-utils/config.js b/node_modules/rxdb/dist/esm/plugins/test-utils/config.js
index c260062..7a60cf2 100644
--- a/node_modules/rxdb/dist/esm/plugins/test-utils/config.js
+++ b/node_modules/rxdb/dist/esm/plugins/test-utils/config.js
@@ -2,7 +2,6 @@
 import { ensureNotFalsy, isPromise, randomCouchString } from "../utils/index.js";
 import { enforceOptions as broadcastChannelEnforceOptions } from 'broadcast-channel';
 import events from 'node:events';
-import { wrappedKeyEncryptionCryptoJsStorage } from "../encryption-crypto-js/index.js";
 export var isDeno = typeof window !== 'undefined' && 'Deno' in window;
 export var isBun = typeof process !== 'undefined' && !!process.versions.bun;
 export var isNode = !isDeno && !isBun && typeof window === 'undefined';
@@ -82,12 +81,6 @@ export function initTestEnvironment() {
     };
   }
 }
-export function getEncryptedStorage(baseStorage = getConfig().storage.getStorage()) {
-  var ret = config.storage.hasEncryption ? baseStorage : wrappedKeyEncryptionCryptoJsStorage({
-    storage: baseStorage
-  });
-  return ret;
-}
 export function isNotOneOfTheseStorages(storageNames) {
   var isName = getConfig().storage.name;
   if (storageNames.includes(isName)) {
diff --git a/node_modules/rxdb/src/plugins/encryption-crypto-js/index.ts b/node_modules/rxdb/src/plugins/encryption-crypto-js/index.ts
deleted file mode 100644
index 4c7c81e..0000000
--- a/node_modules/rxdb/src/plugins/encryption-crypto-js/index.ts
+++ /dev/null
@@ -1,204 +0,0 @@
-/**
- * this plugin adds the encryption-capabilities to rxdb
- * It's using crypto-js/aes for password-encryption
- * @link https://github.com/brix/crypto-js
- */
-import pkg from 'crypto-js';
-const { AES, enc: cryptoEnc } = pkg;
-
-import { wrapRxStorageInstance } from '../../plugin-helpers.ts';
-import { newRxError, newRxTypeError } from '../../rx-error.ts';
-import { hasEncryption } from '../../rx-storage-helper.ts';
-import type {
-    InternalStoreDocType,
-    RxAttachmentWriteData,
-    RxDocumentData,
-    RxDocumentWriteData,
-    RxJsonSchema,
-    RxStorage,
-    RxStorageInstanceCreationParams
-} from '../../types/index.d.ts';
-import {
-    b64DecodeUnicode,
-    b64EncodeUnicode,
-    clone,
-    ensureNotFalsy,
-    flatClone,
-    getProperty,
-    setProperty
-} from '../../plugins/utils/index.ts';
-
-export const MINIMUM_PASSWORD_LENGTH: 8 = 8;
-
-
-export function encryptString(value: string, password: string): string {
-    const encrypted = AES.encrypt(value, password);
-    return encrypted.toString();
-}
-
-export function decryptString(cipherText: string, password: any): string {
-    /**
-     * Trying to decrypt non-strings
-     * will cause no errors and will be hard to debug.
-     * So instead we do this check here.
-     */
-    if (typeof cipherText !== 'string') {
-        throw newRxError('SNH', {
-            args: {
-                cipherText
-            }
-        });
-    }
-
-    const decrypted = AES.decrypt(cipherText, password);
-    const ret = decrypted.toString(cryptoEnc.Utf8);
-    return ret;
-}
-
-export type InternalStorePasswordDocType = InternalStoreDocType<{
-    hash: string;
-}>;
-
-export function wrappedKeyEncryptionCryptoJsStorage<Internals, InstanceCreationOptions>(
-    args: {
-        storage: RxStorage<Internals, InstanceCreationOptions>;
-    }
-): RxStorage<Internals, InstanceCreationOptions> {
-    return Object.assign(
-        {},
-        args.storage,
-        {
-            async createStorageInstance<RxDocType>(
-                params: RxStorageInstanceCreationParams<RxDocType, any>
-            ) {
-                if (typeof params.password !== 'undefined') {
-                    validatePassword(params.password as any);
-                }
-
-                if (!hasEncryption(params.schema)) {
-                    const retInstance = await args.storage.createStorageInstance(params);
-                    return retInstance;
-                }
-
-                if (!params.password) {
-                    throw newRxError('EN3', {
-                        database: params.databaseName,
-                        collection: params.collectionName,
-                        schema: params.schema
-                    });
-                }
-                const password = params.password;
-
-                const schemaWithoutEncrypted: RxJsonSchema<RxDocumentData<RxDocType>> = clone(params.schema);
-                delete schemaWithoutEncrypted.encrypted;
-                if (schemaWithoutEncrypted.attachments) {
-                    schemaWithoutEncrypted.attachments.encrypted = false;
-                }
-
-                const instance = await args.storage.createStorageInstance(
-                    Object.assign(
-                        {},
-                        params,
-                        {
-                            schema: schemaWithoutEncrypted
-                        }
-                    )
-                );
-
-                function modifyToStorage(docData: RxDocumentWriteData<RxDocType>) {
-                    docData = cloneWithoutAttachments(docData);
-                    ensureNotFalsy(params.schema.encrypted)
-                        .forEach(path => {
-                            const value = getProperty(docData, path);
-                            if (typeof value === 'undefined') {
-                                return;
-                            }
-
-                            const stringValue = JSON.stringify(value);
-                            const encrypted = encryptString(stringValue, password);
-                            setProperty(docData, path, encrypted);
-                        });
-
-                    // handle attachments
-                    if (
-                        params.schema.attachments &&
-                        params.schema.attachments.encrypted
-                    ) {
-                        const newAttachments: typeof docData._attachments = {};
-                        Object.entries(docData._attachments).forEach(([id, attachment]) => {
-                            const useAttachment: RxAttachmentWriteData = flatClone(attachment) as any;
-                            if (useAttachment.data) {
-                                const dataString = useAttachment.data;
-                                useAttachment.data = b64EncodeUnicode(encryptString(dataString, password));
-                            }
-                            newAttachments[id] = useAttachment;
-                        });
-                        docData._attachments = newAttachments;
-                    }
-                    return docData;
-                }
-                function modifyFromStorage(docData: RxDocumentData<any>): Promise<RxDocumentData<RxDocType>> {
-                    docData = cloneWithoutAttachments(docData);
-                    ensureNotFalsy(params.schema.encrypted)
-                        .forEach(path => {
-                            const value = getProperty(docData, path);
-                            if (typeof value === 'undefined') {
-                                return;
-                            }
-                            const decrypted = decryptString(value, password);
-                            const decryptedParsed = JSON.parse(decrypted);
-                            setProperty(docData, path, decryptedParsed);
-                        });
-                    return docData;
-                }
-
-                function modifyAttachmentFromStorage(attachmentData: string): string {
-                    if (
-                        params.schema.attachments &&
-                        params.schema.attachments.encrypted
-                    ) {
-                        const decrypted = decryptString(b64DecodeUnicode(attachmentData), password);
-                        return decrypted;
-                    } else {
-                        return attachmentData;
-                    }
-                }
-
-                return wrapRxStorageInstance(
-                    params.schema,
-                    instance,
-                    modifyToStorage,
-                    modifyFromStorage,
-                    modifyAttachmentFromStorage
-                );
-            }
-        }
-    );
-}
-
-
-
-
-
-function cloneWithoutAttachments<T>(data: RxDocumentWriteData<T>): RxDocumentData<T> {
-    const attachments = data._attachments;
-    data = flatClone(data);
-    delete (data as any)._attachments;
-    data = clone(data);
-    data._attachments = attachments;
-    return data as any;
-}
-
-function validatePassword(password: string) {
-    if (typeof password !== 'string') {
-        throw newRxTypeError('EN1', {
-            password
-        });
-    }
-    if (password.length < MINIMUM_PASSWORD_LENGTH) {
-        throw newRxError('EN2', {
-            minPassLength: MINIMUM_PASSWORD_LENGTH,
-            password
-        });
-    }
-}
diff --git a/node_modules/rxdb/src/plugins/test-utils/config.ts b/node_modules/rxdb/src/plugins/test-utils/config.ts
index ecda304..2dbac00 100644
--- a/node_modules/rxdb/src/plugins/test-utils/config.ts
+++ b/node_modules/rxdb/src/plugins/test-utils/config.ts
@@ -11,7 +11,6 @@ import events from 'node:events';
 import * as path from 'node:path';
 import url from 'node:url';
 import type { RxStorage, RxTestStorage } from '../../types';
-import { wrappedKeyEncryptionCryptoJsStorage } from '../encryption-crypto-js/index.ts';
 
 export type TestConfig = {
     storage: RxTestStorage;
@@ -112,15 +111,6 @@ export function initTestEnvironment() {
     }
 }
 
-export function getEncryptedStorage(baseStorage = getConfig().storage.getStorage()): RxStorage<any, any> {
-    const ret = config.storage.hasEncryption ?
-        baseStorage :
-        wrappedKeyEncryptionCryptoJsStorage({
-            storage: baseStorage
-        });
-    return ret;
-}
-
 export function isNotOneOfTheseStorages(storageNames: string[]) {
     const isName = getConfig().storage.name;
     if (storageNames.includes(isName)) {
